#!/usr/bin/env ruby

require 'awesome_print'

if Dir['lib/clitasks.rb'].count > 0 && (Dir['.git'].count > 0 || ENV['CLIT_ENV'] == 'test')
  require './lib/clitasks'
else
  require 'clitasks'
end

class String
  def split_unescaped(str, opts={}, &block)
    self.split(/(?<!\\)#{str}/).map do |s|
      s = s.gsub(/\\(?=#{str})/, '')
      s = s.sub(/^\s*/,'').sub(/\s*$/,'') if opts[:trim] == true
      s = yield s if block_given?
      s
    end
  end
end

module Hero

  class NoteCommand
    attr_accessor :original_args, :args, :stdin, :io
    attr_accessor :subcommand

    def self.run(args=ARGV.clone, io=$stdin)
      new(args, io).process_subcommand
    end

    def initialize(args=ARGV.clone, io=$stdin)
      @original_args = args.clone
      @subcommand = args.shift || 'list'

      @args = args
      @io = io
    end

    def stdin
      io
    end

    def command
      subcommand
    end

    def is_edit_bin_subcommand?
      command[/--?e(d(i(t)?)?)?/] ? true : false
    end

    def edit_bin
      task_bin = File.realpath(__FILE__)
      task_bin_dir = File.dirname(task_bin)
      git_dir = `cd #{task_bin_dir}; git rev-parse --show-toplevel`.chomp
      Dir.chdir(git_dir)
      # files = []
      # if args.count > 0
      #   args.flat_map do |arg|
      #     files += Dir["{bin,lib}/**/*.rb"].grep Regexp.new('.*' + arg.scan(/./).join('.*'))
      #   end
      # end
      # tempfile = Tempfile.new('note-project')
      # %x{find bin lib -type f >#{tempfile.path}}
      # system('vim -O "%s" "bin/%s"' % [tempfile.path, File.basename(task_bin)])   #, task_bin_dir, files.uniq.join(' ')])
      # tempfile.close
      # tempfile.unlink
      CliTasks::ProjectFile.generate(git_dir)
      Dir.chdir(git_dir)
      system(format('vim -O "%s" "%s" "%s"', 'project-index', 'bin/note', 'lib/clitasks/commands.rb'))
      CliTasks::Commands.commit('auto-saving bin/note')
      return true
    end

    def process_subcommand
      return edit_bin if is_edit_bin_subcommand?

      Dir.chdir(CliTasks::Commands.world.path)

      CliTasks.world.use_index = args.shift == '-i' if args.first == '-i'

      case command
      when 'next_filename', 'next'
        puts CliTasks::Commands.next_filename
        return
      when 'index'
        CliTasks::Commands.rebuild
        CliTasks::Commands.index
        CliTasks::Commands.rebuild
      when 'update_index'
        CliTasks::Commands.rebuild
        CliTasks::Commands.update_index
        CliTasks::Commands.rebuild
      when 'print_index'
        CliTasks::Commands.rebuild
        CliTasks::Commands.print_index
        CliTasks::Commands.rebuild
      when 'save', 's'
        CliTasks::Commands.save args, $stdin
        CliTasks::Commands.rebuild
      when 'add', 'a', 'new', 'n', 'create', 'c', 'import', 'i'
        CliTasks::Commands.create args, $stdin
        CliTasks::Commands.rebuild
      when 'reindex'
        CliTasks::Commands.reindex
      when 'rebuild'
        CliTasks::Commands.rebuild
      when 'temp', 'scratch'
        CliTasks::Commands.scratch
        CliTasks::Commands.rebuild
      when 'edit'
        CliTasks::Commands.edit *args
        CliTasks::Commands.rebuild
      when 'tags'
        CliTasks::Commands.rebuild
        CliTasks::Commands.tags *args
      when 'search'
        if args.any?{|arg| arg == '-e' }
          CliTasks::Commands.edit *args.reject{|arg| arg == '-e' }
        else
          ap args: args, splatted: [ *args ]
          return CliTasks::Commands.search *args
          CliTasks::Commands.search *args
        end
        CliTasks::Commands.rebuild
      when 'commit'
        CliTasks::Commands.commit
        return
      when 'backup'
        CliTasks::Commands.backup
        return
      when 'tests'
        label = ->(t) { puts; tt = sprintf("  %s:  ", t); puts tt; puts tt.gsub(/./, ?-); }

#         label.call 'List Tags without Index'
#         CliTasks.world.use_index = false
#         puts Benchmark.measure{ CliTasks::Commands.tags }

#         label.call 'List Tags with Index'
#         CliTasks.world.use_index = true
#         puts Benchmark.measure{ CliTasks::Commands.tags }

#         label.call 'List EPIC Tag w/o index'
#         CliTasks.world.use_index = false
#         puts Benchmark.measure{ CliTasks::Commands.tags 'EPIC' }

#         label.call 'List EPIC Tag w index'
#         CliTasks.world.use_index = true
#         puts Benchmark.measure{ CliTasks::Commands.tags 'EPIC' }

        CliTasks::Commands.rebuild

        label.call 'List EPIC Tag w index'
        CliTasks.world.use_index = true
        Benchmark.measure{ puts CliTasks::Commands.search(  *%w{ EPIC bea planning } ) }

        label.call 'List EPIC Tag w/o index'
        CliTasks.world.use_index = false
        Benchmark.measure{ puts CliTasks::Commands.search(  *%w{ EPIC bea planning } ) }
      when 'test'
        return CliTasks::Commands.test args, $stdin
      when 'list'
        CliTasks::Commands.list *args
      else
        CliTasks::Commands.list *original_args
      end

      commit_file = File.join(CliTasks::Commands.world.task_path, 'commit_count')
      IO.write(commit_file, 0) unless File.exist?(commit_file)
      commit_count = IO.read(commit_file).to_i
      IO.write(commit_file, commit_count + 1)
      if commit_count % 10 == 0
        puts
        puts "There have been 10 commits since the last auto-backup.  Backup up notes now..."
        CliTasks::Commands.commit_and_backup
      else
        CliTasks::Commands.commit
      end

    end

  end
end
# command = ARGV.shift || 'list'

Hero::NoteCommand.run

# vim: ft=ruby
